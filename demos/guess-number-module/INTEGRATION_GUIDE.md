# Calimero SDKé›†æˆæŒ‡å— - çŒœæ•°å­—æ¸¸æˆ

## ğŸ“– æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†å°†ç°æœ‰çŒœæ•°å­—æ¸¸æˆä¸ Calimero Network é›†æˆçš„å®Œæ•´æŒ‡å—ã€‚æ¶µç›–ä»ç¯å¢ƒæ­å»ºåˆ°ç”Ÿäº§éƒ¨ç½²çš„æ‰€æœ‰æ­¥éª¤ï¼Œå¸®åŠ©å¼€å‘è€…å®ç°é“¾ä¸‹æ¸¸æˆé€»è¾‘ä¸é“¾ä¸Šæ•°æ®å­˜å‚¨çš„æ··åˆæ¶æ„ã€‚

## ğŸ¯ é›†æˆç›®æ ‡

- **é“¾ä¸‹æ¸¸æˆä½“éªŒ**ï¼šåœ¨æœ¬åœ°è¿è¡Œæ¸¸æˆé€»è¾‘ï¼Œç¡®ä¿æµç•…çš„ç”¨æˆ·ä½“éªŒ
- **é“¾ä¸Šæ•°æ®æŒä¹…åŒ–**ï¼šå°†æ¸¸æˆç»“æœå’Œç»Ÿè®¡æ•°æ®å­˜å‚¨åˆ°åŒºå—é“¾
- **èº«ä»½ç®¡ç†**ï¼šé›†æˆå»ä¸­å¿ƒåŒ–èº«ä»½(DID)è¿›è¡Œç”¨æˆ·è®¤è¯
- **æ•°æ®éšç§**ï¼šä¿æŠ¤æ¸¸æˆè¿‡ç¨‹éšç§ï¼Œä»…ç»“æœä¸Šé“¾
- **æˆæœ¬ä¼˜åŒ–**ï¼šæœ€å°åŒ–é“¾ä¸Šäº¤äº’ï¼Œé™ä½ Gas è´¹ç”¨

## ğŸ“‹ é›†æˆæ­¥éª¤æ¦‚è§ˆ

### ç¬¬ä¸€é˜¶æ®µï¼šç¯å¢ƒå‡†å¤‡ (Phase 1: Environment Setup)
1. **å¼€å‘ç¯å¢ƒé…ç½®**
2. **Calimero SDK ä¾èµ–å®‰è£…**
3. **ç½‘ç»œè¿æ¥æµ‹è¯•**
4. **èº«ä»½è®¤è¯è®¾ç½®**

### ç¬¬äºŒé˜¶æ®µï¼šå®¢æˆ·ç«¯è¿æ¥ (Phase 2: Client Connection)
5. **Calimero å®¢æˆ·ç«¯åˆå§‹åŒ–**
6. **ä¸Šä¸‹æ–‡ç®¡ç†å™¨è®¾ç½®**
7. **è¿æ¥çŠ¶æ€ç›‘æ§**
8. **é”™è¯¯å¤„ç†æœºåˆ¶**

### ç¬¬ä¸‰é˜¶æ®µï¼šæ•°æ®å¤„ç† (Phase 3: Data Handling)
9. **æ¸¸æˆè®°å½•åºåˆ—åŒ–**
10. **æ•°æ®ç»“æ„æ˜ å°„**
11. **åŠ å¯†ä¼ è¾“é…ç½®**
12. **æ•°æ®éªŒè¯æœºåˆ¶**

### ç¬¬å››é˜¶æ®µï¼šä¸šåŠ¡é€»è¾‘ (Phase 4: Business Logic)
13. **æ¸¸æˆç»“æœå­˜å‚¨é€»è¾‘**
14. **ç»Ÿè®¡æ•°æ®æ›´æ–°**
15. **å†å²è®°å½•æŸ¥è¯¢**
16. **æ’è¡Œæ¦œç»´æŠ¤**

### ç¬¬äº”é˜¶æ®µï¼šé”™è¯¯å¤„ç† (Phase 5: Error Handling)
17. **ç½‘ç»œå¼‚å¸¸å¤„ç†**
18. **é‡è¯•æœºåˆ¶å®ç°**
19. **å›é€€ç­–ç•¥è®¾è®¡**
20. **ç”¨æˆ·åé¦ˆæœºåˆ¶**

### ç¬¬å…­é˜¶æ®µï¼šé«˜çº§ç‰¹æ€§ (Phase 6: Advanced Features)
21. **æ‰¹é‡æ“ä½œä¼˜åŒ–**
22. **ç¼“å­˜ç­–ç•¥å®ç°**
23. **æ€§èƒ½ç›‘æ§**
24. **å®‰å…¨å®¡è®¡**

### ç¬¬ä¸ƒé˜¶æ®µï¼šæµ‹è¯•éªŒè¯ (Phase 7: Testing & Validation)
25. **å•å…ƒæµ‹è¯•ç¼–å†™**
26. **é›†æˆæµ‹è¯•è®¾è®¡**
27. **ç«¯åˆ°ç«¯æµ‹è¯•**
28. **æ€§èƒ½åŸºå‡†æµ‹è¯•**

### ç¬¬å…«é˜¶æ®µï¼šéƒ¨ç½²é…ç½® (Phase 8: Deployment Configuration)
29. **ç”Ÿäº§ç¯å¢ƒé…ç½®**
30. **ç›‘æ§å‘Šè­¦è®¾ç½®**
31. **ç‰ˆæœ¬ç®¡ç†ç­–ç•¥**
32. **æ–‡æ¡£å®Œå–„**

## ğŸ”§ è¯¦ç»†å®æ–½æŒ‡å—

## Phase 1: ç¯å¢ƒå‡†å¤‡

### Step 1: å¼€å‘ç¯å¢ƒé…ç½®

#### å¿…è¦å·¥å…·å®‰è£…
```bash
# 1. å®‰è£… Rust å·¥å…·é“¾
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup update stable
rustup target add wasm32-unknown-unknown

# 2. å®‰è£… Calimero å·¥å…·
cargo install meroctl
cargo install merod

# 3. å®‰è£… NEAR CLI (å¦‚æœä½¿ç”¨ NEAR ä½œä¸ºåç«¯)
npm install -g near-cli
```

#### é¡¹ç›®ç»“æ„è°ƒæ•´
```
demos/guess-number-module/
â”œâ”€â”€ off-chain-game/           # å®¢æˆ·ç«¯æ¸¸æˆé€»è¾‘
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs          # æ¸¸æˆä¸»å…¥å£
â”‚   â”‚   â”œâ”€â”€ game.rs          # æ¸¸æˆé€»è¾‘æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ calimero.rs      # Calimero é›†æˆå±‚
â”‚   â”‚   â””â”€â”€ types.rs         # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ Cargo.toml
â”œâ”€â”€ on-chain-contract/        # æ™ºèƒ½åˆçº¦
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ lib.rs           # åˆçº¦é€»è¾‘
â”‚   â””â”€â”€ Cargo.toml
â””â”€â”€ integration-tests/        # é›†æˆæµ‹è¯•
```

### Step 2: Calimero SDK ä¾èµ–é…ç½®

æ›´æ–° `Cargo.toml` æ–‡ä»¶ï¼š

```toml
[dependencies]
# ç°æœ‰ä¾èµ–ä¿æŒä¸å˜...

# Calimero SDK é›†æˆ
calimero-sdk = { path = "../../../crates/sdk" }
calimero-primitives = { path = "../../../crates/primitives" }
calimero-context = { path = "../../../crates/context" }
calimero-store = { path = "../../../crates/store" }
calimero-network = { path = "../../../crates/network" }

# é¢å¤–çš„ç½‘ç»œå’ŒåŠ å¯†åº“
tokio-tungstenite = "0.20"
url = "2.5"
base58 = "0.2"
ed25519-dalek = "2.0"
```

### Step 3: ç½‘ç»œè¿æ¥æµ‹è¯•

åˆ›å»ºè¿æ¥æµ‹è¯•è„šæœ¬ï¼š

```bash
#!/bin/bash
# scripts/test-connection.sh

echo "ğŸ”— æµ‹è¯• Calimero ç½‘ç»œè¿æ¥..."

# 1. æ£€æŸ¥æœ¬åœ°èŠ‚ç‚¹çŠ¶æ€
merod --version
echo "âœ… Calimero èŠ‚ç‚¹å¯ç”¨"

# 2. æµ‹è¯•ç½‘ç»œè¿æ¥
meroctl node ping --node-url http://127.0.0.1:2428
echo "âœ… ç½‘ç»œè¿æ¥æ­£å¸¸"

# 3. éªŒè¯ä¸Šä¸‹æ–‡åˆ›å»º
meroctl context create --name test-context
echo "âœ… ä¸Šä¸‹æ–‡åˆ›å»ºæˆåŠŸ"

# 4. æ¸…ç†æµ‹è¯•èµ„æº
meroctl context delete --name test-context
echo "âœ… è¿æ¥æµ‹è¯•å®Œæˆ"
```

## Phase 2: å®¢æˆ·ç«¯è¿æ¥

### Step 4: Calimero å®¢æˆ·ç«¯åˆå§‹åŒ–

åˆ›å»º `src/calimero.rs` é›†æˆæ¨¡å—ï¼š

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use calimero_sdk::env;
use calimero_primitives::{ContextId, Identity};
use calimero_context::ContextManager;
use eyre::{Result, Context};

pub struct CalimeroClient {
    context_manager: Arc<RwLock<Option<ContextManager>>>,
    context_id: Option<ContextId>,
    identity: Option<Identity>,
}

impl CalimeroClient {
    pub fn new() -> Self {
        Self {
            context_manager: Arc::new(RwLock::new(None)),
            context_id: None,
            identity: None,
        }
    }

    /// åˆå§‹åŒ– Calimero è¿æ¥
    pub async fn initialize(&mut self, node_url: &str) -> Result<()> {
        println!("ğŸ”— æ­£åœ¨è¿æ¥ Calimero ç½‘ç»œ...");
        
        // 1. åˆ›å»ºèº«ä»½
        self.identity = Some(self.create_identity().await?);
        
        // 2. è¿æ¥åˆ°èŠ‚ç‚¹
        let context_manager = self.connect_to_node(node_url).await
            .context("Failed to connect to Calimero node")?;
        
        // 3. åˆ›å»ºæˆ–è·å–æ¸¸æˆä¸Šä¸‹æ–‡
        let context_id = self.setup_game_context(&context_manager).await?;
        
        *self.context_manager.write().await = Some(context_manager);
        self.context_id = Some(context_id);
        
        println!("âœ… å·²è¿æ¥åˆ° Calimero ç½‘ç»œ");
        Ok(())
    }

    /// æ£€æŸ¥è¿æ¥çŠ¶æ€
    pub async fn is_connected(&self) -> bool {
        self.context_manager.read().await.is_some()
    }

    /// è·å–ä¸Šä¸‹æ–‡ID
    pub fn context_id(&self) -> Option<&ContextId> {
        self.context_id.as_ref()
    }
}

// ç§æœ‰æ–¹æ³•å®ç°
impl CalimeroClient {
    async fn create_identity(&self) -> Result<Identity> {
        // åˆ›å»ºæˆ–åŠ è½½ç”¨æˆ·èº«ä»½
        todo!("å®ç°èº«ä»½åˆ›å»ºé€»è¾‘")
    }

    async fn connect_to_node(&self, node_url: &str) -> Result<ContextManager> {
        // è¿æ¥åˆ° Calimero èŠ‚ç‚¹
        todo!("å®ç°èŠ‚ç‚¹è¿æ¥é€»è¾‘")
    }

    async fn setup_game_context(&self, manager: &ContextManager) -> Result<ContextId> {
        // è®¾ç½®æ¸¸æˆä¸“ç”¨ä¸Šä¸‹æ–‡
        todo!("å®ç°ä¸Šä¸‹æ–‡è®¾ç½®é€»è¾‘")
    }
}
```

### Step 5: ä¸Šä¸‹æ–‡ç®¡ç†å™¨é…ç½®

åˆ›å»ºæ¸¸æˆä¸“ç”¨ä¸Šä¸‹æ–‡é…ç½®ï¼š

```rust
// src/context.rs
use calimero_sdk::types::{ContextConfig, ExecutionEnvironment};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameContextConfig {
    pub max_players: u32,
    pub game_timeout: u64,
    pub result_retention_days: u32,
    pub privacy_level: PrivacyLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PrivacyLevel {
    Public,    // æ‰€æœ‰æ•°æ®å…¬å¼€
    Private,   // ä»…ç»“æœå…¬å¼€
    Anonymous, // å®Œå…¨åŒ¿å
}

impl Default for GameContextConfig {
    fn default() -> Self {
        Self {
            max_players: 1000,
            game_timeout: 3600, // 1 hour
            result_retention_days: 365,
            privacy_level: PrivacyLevel::Private,
        }
    }
}

pub fn create_game_context_config() -> ContextConfig {
    ContextConfig {
        environment: ExecutionEnvironment::Local,
        // å…¶ä»–é…ç½®é¡¹...
    }
}
```

## Phase 3: æ•°æ®å¤„ç†

### Step 6: æ•°æ®ç»“æ„æ˜ å°„

æ›´æ–°æ¸¸æˆæ•°æ®ç»“æ„ä»¥æ”¯æŒ Calimero åºåˆ—åŒ–ï¼š

```rust
// src/types.rs
use calimero_sdk::{borsh, serde};
use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct GameRecord {
    pub game_id: Uuid,
    pub player_id: String,
    pub target_number: u32,
    pub attempts: u32,
    pub guesses: Vec<u32>,
    pub duration_seconds: u64,
    pub timestamp: u64,
    pub success: bool,
    pub difficulty: String,
    // Calimero ä¸“ç”¨å­—æ®µ
    pub context_id: Option<String>,
    pub transaction_hash: Option<String>,
    pub block_height: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub struct PlayerStats {
    pub player_id: String,
    pub total_games: u32,
    pub total_wins: u32,
    pub average_attempts: f64,
    pub best_score: u32,
    pub total_time: u64,
    pub win_rate: f64,
    // é“¾ä¸Šæ•°æ®éªŒè¯
    pub last_updated: u64,
    pub data_hash: Option<String>,
}

// æ¸¸æˆäº‹ä»¶å®šä¹‰
#[derive(Debug, Clone, Serialize, Deserialize, BorshSerialize, BorshDeserialize)]
pub enum GameEvent {
    GameStarted {
        game_id: Uuid,
        player_id: String,
        difficulty: String,
        timestamp: u64,
    },
    GameEnded {
        game_id: Uuid,
        result: GameRecord,
    },
    StatisticsUpdated {
        player_id: String,
        stats: PlayerStats,
    },
}
```

### Step 7: æ•°æ®åŠ å¯†å’Œåºåˆ—åŒ–

å®ç°æ•°æ®ä¿æŠ¤æœºåˆ¶ï¼š

```rust
// src/encryption.rs
use calimero_sdk::env;
use eyre::{Result, Context};
use serde::{Deserialize, Serialize};

pub struct DataProtection;

impl DataProtection {
    /// åŠ å¯†æ•æ„Ÿæ¸¸æˆæ•°æ®
    pub fn encrypt_game_data<T>(data: &T) -> Result<Vec<u8>>
    where
        T: Serialize,
    {
        let serialized = serde_json::to_vec(data)
            .context("Failed to serialize game data")?;
        
        // ä½¿ç”¨ Calimero ç¯å¢ƒæä¾›çš„åŠ å¯†åŠŸèƒ½
        let encrypted = env::crypto::encrypt(&serialized)
            .context("Failed to encrypt game data")?;
        
        Ok(encrypted)
    }

    /// è§£å¯†æ¸¸æˆæ•°æ®
    pub fn decrypt_game_data<T>(encrypted_data: &[u8]) -> Result<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        let decrypted = env::crypto::decrypt(encrypted_data)
            .context("Failed to decrypt game data")?;
        
        let deserialized = serde_json::from_slice(&decrypted)
            .context("Failed to deserialize game data")?;
        
        Ok(deserialized)
    }

    /// è®¡ç®—æ•°æ®å®Œæ•´æ€§å“ˆå¸Œ
    pub fn compute_hash<T>(data: &T) -> Result<String>
    where
        T: Serialize,
    {
        let serialized = serde_json::to_vec(data)?;
        let hash = env::crypto::hash(&serialized);
        Ok(base58::encode(&hash))
    }
}
```

## Phase 4: ä¸šåŠ¡é€»è¾‘å®ç°

### Step 8: æ¸¸æˆç»“æœå­˜å‚¨é€»è¾‘

å®ç°æ ¸å¿ƒçš„ `store_game_result` æ–¹æ³•ï¼š

```rust
// src/storage.rs
use crate::{CalimeroClient, GameRecord, GameEvent, DataProtection};
use calimero_sdk::{env, app::Result};
use uuid::Uuid;

pub struct GameStorage {
    client: CalimeroClient,
}

impl GameStorage {
    pub fn new(client: CalimeroClient) -> Self {
        Self { client }
    }

    /// å­˜å‚¨æ¸¸æˆç»“æœåˆ° Calimero
    pub async fn store_game_result(&self, record: &GameRecord) -> Result<String> {
        // 1. éªŒè¯è¿æ¥çŠ¶æ€
        if !self.client.is_connected().await {
            return Err("Not connected to Calimero network".into());
        }

        // 2. å‡†å¤‡æ•°æ®
        let mut record = record.clone();
        record.context_id = self.client.context_id()
            .map(|id| id.to_string());

        // 3. åŠ å¯†æ•æ„Ÿæ•°æ®
        let encrypted_guesses = DataProtection::encrypt_game_data(&record.guesses)?;
        
        // 4. åˆ›å»ºæ¸¸æˆäº‹ä»¶
        let game_event = GameEvent::GameEnded {
            game_id: record.game_id,
            result: record.clone(),
        };

        // 5. æäº¤åˆ°é“¾ä¸Š
        let transaction_result = self.submit_to_blockchain(&game_event).await?;
        
        // 6. æ›´æ–°æœ¬åœ°è®°å½•
        record.transaction_hash = Some(transaction_result.tx_hash.clone());
        record.block_height = Some(transaction_result.block_height);

        // 7. æ›´æ–°ç©å®¶ç»Ÿè®¡
        self.update_player_stats(&record).await?;

        println!("âœ… æ¸¸æˆç»“æœå·²ä¿å­˜åˆ°åŒºå—é“¾");
        println!("ğŸ“ äº¤æ˜“å“ˆå¸Œ: {}", transaction_result.tx_hash);

        Ok(transaction_result.tx_hash)
    }

    /// æ‰¹é‡å­˜å‚¨å¤šä¸ªæ¸¸æˆç»“æœ
    pub async fn batch_store_results(&self, records: &[GameRecord]) -> Result<Vec<String>> {
        let mut transaction_hashes = Vec::new();
        
        for record in records {
            match self.store_game_result(record).await {
                Ok(hash) => transaction_hashes.push(hash),
                Err(e) => {
                    println!("âš ï¸ å­˜å‚¨æ¸¸æˆè®°å½• {} å¤±è´¥: {}", record.game_id, e);
                    // ç»§ç»­å¤„ç†å…¶ä»–è®°å½•
                }
            }
        }

        Ok(transaction_hashes)
    }
}

// ç§æœ‰æ–¹æ³•
impl GameStorage {
    async fn submit_to_blockchain(&self, event: &GameEvent) -> Result<TransactionResult> {
        // ä½¿ç”¨ Calimero SDK æäº¤äº¤æ˜“
        let context_id = self.client.context_id()
            .ok_or("No context available")?;

        // åºåˆ—åŒ–äº‹ä»¶æ•°æ®
        let event_data = serde_json::to_vec(event)?;

        // è°ƒç”¨æ™ºèƒ½åˆçº¦æ–¹æ³•
        let result = env::context::call_method(
            context_id,
            "store_game_result",
            &event_data,
        ).await?;

        Ok(result.into())
    }

    async fn update_player_stats(&self, record: &GameRecord) -> Result<()> {
        // è·å–å½“å‰ç»Ÿè®¡æ•°æ®
        let mut stats = self.get_player_stats(&record.player_id).await
            .unwrap_or_else(|_| self.create_default_stats(&record.player_id));

        // æ›´æ–°ç»Ÿè®¡æ•°æ®
        stats.total_games += 1;
        if record.success {
            stats.total_wins += 1;
        }
        
        // é‡æ–°è®¡ç®—å¹³å‡å€¼
        let total_attempts: u32 = stats.average_attempts as u32 * (stats.total_games - 1) + record.attempts;
        stats.average_attempts = total_attempts as f64 / stats.total_games as f64;
        
        // æ›´æ–°æœ€ä½³è®°å½•
        if record.success && (stats.best_score == 0 || record.attempts < stats.best_score) {
            stats.best_score = record.attempts;
        }
        
        // æ›´æ–°èƒœç‡
        stats.win_rate = (stats.total_wins as f64 / stats.total_games as f64) * 100.0;
        
        // å­˜å‚¨æ›´æ–°åçš„ç»Ÿè®¡æ•°æ®
        self.store_player_stats(&stats).await?;

        Ok(())
    }
}

#[derive(Debug)]
struct TransactionResult {
    tx_hash: String,
    block_height: u64,
}
```

### Step 9: é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

å®ç°å¥å£®çš„é”™è¯¯å¤„ç†ï¼š

```rust
// src/error_handling.rs
use std::time::Duration;
use tokio::time::sleep;
use eyre::{Result, Context};

pub struct RetryConfig {
    pub max_attempts: usize,
    pub base_delay: Duration,
    pub max_delay: Duration,
    pub exponential_base: f64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay: Duration::from_millis(1000),
            max_delay: Duration::from_secs(30),
            exponential_base: 2.0,
        }
    }
}

pub async fn retry_with_backoff<F, T, E>(
    mut operation: F,
    config: RetryConfig,
) -> Result<T>
where
    F: FnMut() -> Result<T, E>,
    E: std::error::Error + Send + Sync + 'static,
{
    let mut last_error = None;
    
    for attempt in 0..config.max_attempts {
        match operation() {
            Ok(result) => return Ok(result),
            Err(error) => {
                last_error = Some(error);
                
                if attempt < config.max_attempts - 1 {
                    let delay = calculate_delay(attempt, &config);
                    println!("âš ï¸ å°è¯• {} å¤±è´¥ï¼Œ{} ç§’åé‡è¯•...", attempt + 1, delay.as_secs());
                    sleep(delay).await;
                }
            }
        }
    }

    Err(eyre::eyre!(
        "æ“ä½œå¤±è´¥ï¼Œå·²é‡è¯• {} æ¬¡ã€‚æœ€åé”™è¯¯: {:?}",
        config.max_attempts,
        last_error.unwrap()
    ))
}

fn calculate_delay(attempt: usize, config: &RetryConfig) -> Duration {
    let delay = config.base_delay.as_millis() as f64 
        * config.exponential_base.powi(attempt as i32);
    
    let delay = Duration::from_millis(delay as u64);
    std::cmp::min(delay, config.max_delay)
}

// ç½‘ç»œé”™è¯¯å¤„ç†
pub fn handle_network_error(error: &dyn std::error::Error) -> bool {
    let error_str = error.to_string().to_lowercase();
    
    // å¯é‡è¯•çš„ç½‘ç»œé”™è¯¯
    error_str.contains("timeout") ||
    error_str.contains("connection refused") ||
    error_str.contains("network unreachable") ||
    error_str.contains("temporary failure")
}
```

## Phase 5: é«˜çº§ç‰¹æ€§å®ç°

### Step 10: ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–

å®ç°æœ¬åœ°ç¼“å­˜æœºåˆ¶ï¼š

```rust
// src/cache.rs
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};
use serde::{Deserialize, Serialize};

pub struct GameCache {
    stats_cache: Arc<RwLock<HashMap<String, CachedPlayerStats>>>,
    history_cache: Arc<RwLock<HashMap<String, CachedGameHistory>>>,
    cache_ttl: Duration,
}

#[derive(Clone)]
struct CachedPlayerStats {
    data: PlayerStats,
    cached_at: Instant,
}

#[derive(Clone)]
struct CachedGameHistory {
    data: Vec<GameRecord>,
    cached_at: Instant,
}

impl GameCache {
    pub fn new(cache_ttl: Duration) -> Self {
        Self {
            stats_cache: Arc::new(RwLock::new(HashMap::new())),
            history_cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl,
        }
    }

    /// ç¼“å­˜ç©å®¶ç»Ÿè®¡æ•°æ®
    pub async fn cache_player_stats(&self, player_id: &str, stats: PlayerStats) {
        let cached_stats = CachedPlayerStats {
            data: stats,
            cached_at: Instant::now(),
        };
        
        self.stats_cache.write().await
            .insert(player_id.to_string(), cached_stats);
    }

    /// è·å–ç¼“å­˜çš„ç©å®¶ç»Ÿè®¡æ•°æ®
    pub async fn get_cached_player_stats(&self, player_id: &str) -> Option<PlayerStats> {
        let cache = self.stats_cache.read().await;
        
        if let Some(cached) = cache.get(player_id) {
            if cached.cached_at.elapsed() < self.cache_ttl {
                return Some(cached.data.clone());
            }
        }
        
        None
    }

    /// æ¸…ç†è¿‡æœŸç¼“å­˜
    pub async fn cleanup_expired_cache(&self) {
        let mut stats_cache = self.stats_cache.write().await;
        let mut history_cache = self.history_cache.write().await;
        
        stats_cache.retain(|_, cached| {
            cached.cached_at.elapsed() < self.cache_ttl
        });
        
        history_cache.retain(|_, cached| {
            cached.cached_at.elapsed() < self.cache_ttl
        });
    }
}
```

### Step 11: ç›‘æ§å’Œæ—¥å¿—

å®ç°ç›‘æ§ç³»ç»Ÿï¼š

```rust
// src/monitoring.rs
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use tokio::time::{Duration, Instant};
use tracing::{info, warn, error};

pub struct GameMetrics {
    total_games: AtomicU64,
    successful_stores: AtomicU64,
    failed_stores: AtomicU64,
    average_store_time: Arc<RwLock<Duration>>,
    last_successful_store: Arc<RwLock<Option<Instant>>>,
}

impl GameMetrics {
    pub fn new() -> Self {
        Self {
            total_games: AtomicU64::new(0),
            successful_stores: AtomicU64::new(0),
            failed_stores: AtomicU64::new(0),
            average_store_time: Arc::new(RwLock::new(Duration::default())),
            last_successful_store: Arc::new(RwLock::new(None)),
        }
    }

    pub fn record_game_start(&self) {
        self.total_games.fetch_add(1, Ordering::Relaxed);
        info!("æ–°æ¸¸æˆå¼€å§‹ï¼Œæ€»æ¸¸æˆæ•°: {}", self.total_games.load(Ordering::Relaxed));
    }

    pub async fn record_successful_store(&self, duration: Duration) {
        self.successful_stores.fetch_add(1, Ordering::Relaxed);
        *self.last_successful_store.write().await = Some(Instant::now());
        
        // æ›´æ–°å¹³å‡å­˜å‚¨æ—¶é—´
        let mut avg_time = self.average_store_time.write().await;
        let total_successful = self.successful_stores.load(Ordering::Relaxed) as f64;
        let current_avg = avg_time.as_millis() as f64;
        let new_avg = (current_avg * (total_successful - 1.0) + duration.as_millis() as f64) / total_successful;
        *avg_time = Duration::from_millis(new_avg as u64);

        info!(
            "æ¸¸æˆç»“æœå­˜å‚¨æˆåŠŸï¼Œç”¨æ—¶: {:?}msï¼ŒæˆåŠŸç‡: {:.2}%",
            duration.as_millis(),
            self.success_rate()
        );
    }

    pub fn record_failed_store(&self, error: &str) {
        self.failed_stores.fetch_add(1, Ordering::Relaxed);
        error!("æ¸¸æˆç»“æœå­˜å‚¨å¤±è´¥: {}ï¼Œå¤±è´¥ç‡: {:.2}%", error, 100.0 - self.success_rate());
    }

    pub fn success_rate(&self) -> f64 {
        let total_attempts = self.successful_stores.load(Ordering::Relaxed) + 
                           self.failed_stores.load(Ordering::Relaxed);
        
        if total_attempts == 0 {
            return 100.0;
        }
        
        (self.successful_stores.load(Ordering::Relaxed) as f64 / total_attempts as f64) * 100.0
    }

    pub async fn print_metrics(&self) {
        let avg_time = self.average_store_time.read().await;
        let last_store = self.last_successful_store.read().await;
        
        println!("\nğŸ“Š æ¸¸æˆç»Ÿè®¡æŒ‡æ ‡:");
        println!("   ğŸ® æ€»æ¸¸æˆæ•°: {}", self.total_games.load(Ordering::Relaxed));
        println!("   âœ… æˆåŠŸå­˜å‚¨: {}", self.successful_stores.load(Ordering::Relaxed));
        println!("   âŒ å¤±è´¥å­˜å‚¨: {}", self.failed_stores.load(Ordering::Relaxed));
        println!("   ğŸ“ˆ æˆåŠŸç‡: {:.2}%", self.success_rate());
        println!("   â±ï¸  å¹³å‡å­˜å‚¨æ—¶é—´: {:?}ms", avg_time.as_millis());
        
        if let Some(last) = *last_store {
            println!("   ğŸ• æœ€åæˆåŠŸå­˜å‚¨: {:?} å‰", last.elapsed());
        }
    }
}
```

## Phase 6: æµ‹è¯•æ¡†æ¶

### Step 12: é›†æˆæµ‹è¯•

åˆ›å»ºå®Œæ•´çš„æµ‹è¯•å¥—ä»¶ï¼š

```rust
// tests/integration_tests.rs
use tokio_test;
use tempdir::TempDir;
use std::time::Duration;

mod common;
use common::*;

#[tokio::test]
async fn test_game_result_storage() -> Result<()> {
    let test_env = setup_test_environment().await?;
    
    // 1. åˆ›å»ºæµ‹è¯•æ¸¸æˆè®°å½•
    let game_record = create_test_game_record("test_player_1", true);
    
    // 2. å­˜å‚¨æ¸¸æˆç»“æœ
    let storage = GameStorage::new(test_env.client);
    let tx_hash = storage.store_game_result(&game_record).await?;
    
    // 3. éªŒè¯å­˜å‚¨ç»“æœ
    assert!(!tx_hash.is_empty());
    
    // 4. éªŒè¯ç»Ÿè®¡æ•°æ®æ›´æ–°
    let stats = storage.get_player_stats("test_player_1").await?;
    assert_eq!(stats.total_games, 1);
    assert_eq!(stats.total_wins, 1);
    
    Ok(())
}

#[tokio::test]
async fn test_batch_storage() -> Result<()> {
    let test_env = setup_test_environment().await?;
    
    // åˆ›å»ºå¤šä¸ªæµ‹è¯•è®°å½•
    let records = vec![
        create_test_game_record("test_player_2", true),
        create_test_game_record("test_player_2", false),
        create_test_game_record("test_player_2", true),
    ];
    
    let storage = GameStorage::new(test_env.client);
    let tx_hashes = storage.batch_store_results(&records).await?;
    
    assert_eq!(tx_hashes.len(), 3);
    
    // éªŒè¯ç»Ÿè®¡æ•°æ®
    let stats = storage.get_player_stats("test_player_2").await?;
    assert_eq!(stats.total_games, 3);
    assert_eq!(stats.total_wins, 2);
    assert_eq!(stats.win_rate, 66.67);
    
    Ok(())
}

#[tokio::test]
async fn test_error_handling_and_retry() -> Result<()> {
    let mut test_env = setup_test_environment().await?;
    
    // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
    test_env.simulate_network_error().await;
    
    let game_record = create_test_game_record("test_player_3", true);
    let storage = GameStorage::new(test_env.client);
    
    // åº”è¯¥é‡è¯•å¹¶æœ€ç»ˆæˆåŠŸ
    let result = storage.store_game_result(&game_record).await;
    
    // æ ¹æ®é‡è¯•æœºåˆ¶ï¼Œåº”è¯¥æœ€ç»ˆæˆåŠŸ
    assert!(result.is_ok());
    
    Ok(())
}

#[tokio::test]
async fn test_cache_functionality() -> Result<()> {
    let test_env = setup_test_environment().await?;
    let cache = GameCache::new(Duration::from_secs(60));
    
    // æµ‹è¯•ç¼“å­˜å­˜å‚¨å’Œè·å–
    let stats = create_test_player_stats("test_player_4");
    cache.cache_player_stats("test_player_4", stats.clone()).await;
    
    let cached_stats = cache.get_cached_player_stats("test_player_4").await;
    assert!(cached_stats.is_some());
    assert_eq!(cached_stats.unwrap().player_id, stats.player_id);
    
    Ok(())
}

// æ€§èƒ½åŸºå‡†æµ‹è¯•
#[tokio::test]
async fn benchmark_storage_performance() -> Result<()> {
    let test_env = setup_test_environment().await?;
    let storage = GameStorage::new(test_env.client);
    let metrics = GameMetrics::new();
    
    let start_time = Instant::now();
    let num_games = 100;
    
    for i in 0..num_games {
        let record = create_test_game_record(&format!("benchmark_player_{}", i), i % 2 == 0);
        metrics.record_game_start();
        
        let store_start = Instant::now();
        let result = storage.store_game_result(&record).await;
        let store_duration = store_start.elapsed();
        
        match result {
            Ok(_) => metrics.record_successful_store(store_duration).await,
            Err(e) => metrics.record_failed_store(&e.to_string()),
        }
    }
    
    let total_time = start_time.elapsed();
    metrics.print_metrics().await;
    
    println!("åŸºå‡†æµ‹è¯•å®Œæˆ:");
    println!("  æ€»æ—¶é—´: {:?}", total_time);
    println!("  å¹³å‡æ¯ä¸ªæ¸¸æˆ: {:?}", total_time / num_games);
    println!("  æ¯ç§’æ¸¸æˆæ•°: {:.2}", num_games as f64 / total_time.as_secs_f64());
    
    // æ€§èƒ½æ–­è¨€
    assert!(metrics.success_rate() > 95.0, "æˆåŠŸç‡åº”è¯¥å¤§äº95%");
    assert!(total_time < Duration::from_secs(30), "100ä¸ªæ¸¸æˆåº”è¯¥åœ¨30ç§’å†…å®Œæˆ");
    
    Ok(())
}
```

## Phase 7: éƒ¨ç½²é…ç½®

### Step 13: ç”Ÿäº§ç¯å¢ƒé…ç½®

åˆ›å»ºç”Ÿäº§ç¯å¢ƒé…ç½®æ–‡ä»¶ï¼š

```toml
# config/production.toml
[calimero]
node_url = "https://mainnet.calimero.network"
context_id = "guess-number-production"
timeout_seconds = 30

[network]
max_connections = 100
keepalive_interval = 30
reconnect_attempts = 5

[storage]
batch_size = 50
batch_timeout = 5
cache_ttl_seconds = 300

[security]
encryption_enabled = true
data_validation = true
rate_limiting = true
max_requests_per_minute = 60

[monitoring]
enable_metrics = true
log_level = "info"
metrics_port = 9090

[performance]
worker_threads = 4
max_concurrent_games = 1000
```

### Step 14: éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# deploy.sh

set -e

echo "ğŸš€ å¼€å§‹éƒ¨ç½²çŒœæ•°å­—æ¸¸æˆ..."

# 1. æ„å»ºé¡¹ç›®
echo "ğŸ“¦ æ„å»ºé¡¹ç›®..."
cargo build --release --bin guess-number-client
cargo build --release --bin guess-number-server

# 2. è¿è¡Œæµ‹è¯•
echo "ğŸ§ª è¿è¡Œæµ‹è¯•..."
cargo test --release

# 3. æ„å»º Docker é•œåƒ
echo "ğŸ³ æ„å»º Docker é•œåƒ..."
docker build -t guess-number-game:latest .

# 4. éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
echo "ğŸŒ éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ..."
docker-compose -f docker-compose.prod.yml up -d

# 5. å¥åº·æ£€æŸ¥
echo "ğŸ” æ‰§è¡Œå¥åº·æ£€æŸ¥..."
timeout 60 bash -c '
while [[ "$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)" != "200" ]]; do
    echo "ç­‰å¾…æœåŠ¡å¯åŠ¨..."
    sleep 5
done
'

echo "âœ… éƒ¨ç½²å®Œæˆï¼"
echo "ğŸŒ æ¸¸æˆæœåŠ¡: http://localhost:8080"
echo "ğŸ“Š ç›‘æ§é¢æ¿: http://localhost:9090"
```

## ğŸ“Š ç›‘æ§å’Œè¿ç»´

### å¥åº·æ£€æŸ¥ç«¯ç‚¹

```rust
// src/health.rs
use axum::{Json, response::Json as JsonResponse};
use serde_json::json;

pub async fn health_check() -> JsonResponse<serde_json::Value> {
    JsonResponse(json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now().to_rfc3339(),
        "version": env!("CARGO_PKG_VERSION"),
        "services": {
            "calimero": check_calimero_connection().await,
            "database": check_database_connection().await,
            "cache": check_cache_status().await
        }
    }))
}

async fn check_calimero_connection() -> &'static str {
    // æ£€æŸ¥ Calimero è¿æ¥çŠ¶æ€
    "connected"
}
```

### æŒ‡æ ‡æ”¶é›†

```rust
// src/metrics.rs
use prometheus::{Counter, Histogram, register_counter, register_histogram};
use std::sync::Once;

static INIT: Once = Once::new();

pub struct Metrics {
    pub games_total: Counter,
    pub storage_duration: Histogram,
    pub errors_total: Counter,
}

impl Metrics {
    pub fn new() -> Self {
        INIT.call_once(|| {
            // æ³¨å†ŒæŒ‡æ ‡
        });

        Self {
            games_total: register_counter!("games_total", "Total number of games played").unwrap(),
            storage_duration: register_histogram!("storage_duration_seconds", "Time taken to store game results").unwrap(),
            errors_total: register_counter!("errors_total", "Total number of errors").unwrap(),
        }
    }
}
```

## ğŸ”’ å®‰å…¨è€ƒè™‘

### æ•°æ®éªŒè¯

```rust
// src/validation.rs
use eyre::{Result, bail};

pub fn validate_game_record(record: &GameRecord) -> Result<()> {
    // åŸºæœ¬å­—æ®µéªŒè¯
    if record.player_id.is_empty() {
        bail!("ç©å®¶IDä¸èƒ½ä¸ºç©º");
    }
    
    if record.attempts == 0 {
        bail!("å°è¯•æ¬¡æ•°å¿…é¡»å¤§äº0");
    }
    
    if record.guesses.len() != record.attempts as usize {
        bail!("çŒœæµ‹è®°å½•æ•°é‡ä¸å°è¯•æ¬¡æ•°ä¸åŒ¹é…");
    }
    
    // æ¸¸æˆé€»è¾‘éªŒè¯
    if let Some(&last_guess) = record.guesses.last() {
        if record.success && last_guess != record.target_number {
            bail!("æˆåŠŸæ ‡è®°ä¸æœ€åçŒœæµ‹ä¸ç¬¦");
        }
    }
    
    // æ—¶é—´éªŒè¯
    let max_game_duration = 3600; // 1å°æ—¶
    if record.duration_seconds > max_game_duration {
        bail!("æ¸¸æˆæ—¶é•¿è¶…è¿‡æœ€å¤§å…è®¸æ—¶é—´");
    }
    
    Ok(())
}
```

### æƒé™ç®¡ç†

```rust
// src/auth.rs
use calimero_primitives::Identity;

pub struct AuthManager {
    allowed_identities: Vec<Identity>,
}

impl AuthManager {
    pub fn verify_player_identity(&self, identity: &Identity) -> bool {
        // éªŒè¯ç©å®¶èº«ä»½
        self.allowed_identities.contains(identity)
    }
    
    pub fn check_rate_limit(&self, player_id: &str) -> bool {
        // æ£€æŸ¥é€Ÿç‡é™åˆ¶
        true // å®ç°å…·ä½“é€»è¾‘
    }
}
```

## ğŸ“ ä½¿ç”¨æŒ‡å—

### 1. å¿«é€Ÿå¼€å§‹

```bash
# å®‰è£…å’Œè¿è¡Œ
git clone https://github.com/calimero-network/core.git
cd core/demos/guess-number-module/off-chain-game

# å®‰è£…ä¾èµ–
cargo build

# è¿è¡Œæ¸¸æˆ
cargo run --bin guess-number-client play --player "your-player-id"
```

### 2. é«˜çº§é…ç½®

```bash
# è‡ªå®šä¹‰éš¾åº¦å’Œå°è¯•æ¬¡æ•°
cargo run --bin guess-number-client play --difficulty hard --max-attempts 15

# æŸ¥çœ‹ç»Ÿè®¡æ•°æ®
cargo run --bin guess-number-client stats --player "your-player-id"

# æŸ¥çœ‹å†å²è®°å½•
cargo run --bin guess-number-client history --player "your-player-id"
```

### 3. Web ç•Œé¢

```bash
# å¯åŠ¨ Web æœåŠ¡
cargo run --bin guess-number-server

# è®¿é—®æ¸¸æˆç•Œé¢
open http://localhost:8080
```

## ğŸ”§ æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **è¿æ¥å¤±è´¥**
   ```bash
   # æ£€æŸ¥ Calimero èŠ‚ç‚¹çŠ¶æ€
   meroctl node status
   
   # é‡å¯æœ¬åœ°èŠ‚ç‚¹
   merod restart
   ```

2. **å­˜å‚¨å¤±è´¥**
   ```bash
   # æ£€æŸ¥ä¸Šä¸‹æ–‡çŠ¶æ€
   meroctl context list
   
   # é‡æ–°åˆ›å»ºä¸Šä¸‹æ–‡
   meroctl context create --name guess-number-game
   ```

3. **æ€§èƒ½é—®é¢˜**
   ```bash
   # æŸ¥çœ‹æ—¥å¿—
   tail -f logs/guess-number.log
   
   # æ£€æŸ¥èµ„æºä½¿ç”¨
   docker stats guess-number-game
   ```

## ğŸš€ åç»­å¼€å‘è®¡åˆ’

### çŸ­æœŸç›®æ ‡ (1-2 ä¸ªæœˆ)
- [ ] å®Œå–„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- [ ] å®ç°æ›´å¤šæ¸¸æˆæ¨¡å¼ (å¤šäººæ¨¡å¼ã€ç«é€Ÿæ¨¡å¼)
- [ ] ä¼˜åŒ–å­˜å‚¨æ€§èƒ½å’Œæ‰¹é‡æ“ä½œ
- [ ] æ·»åŠ æ¸¸æˆå†…è´­å’Œå¥–åŠ±æœºåˆ¶

### é•¿æœŸç›®æ ‡ (3-6 ä¸ªæœˆ)
- [ ] é›†æˆæ›´å¤šåŒºå—é“¾ç½‘ç»œ (Ethereum, Polygon)
- [ ] å®ç°è·¨é“¾æ¸¸æˆèµ„äº§è½¬ç§»
- [ ] å¼€å‘ç§»åŠ¨ç«¯åº”ç”¨
- [ ] æ„å»ºæ¸¸æˆç”Ÿæ€ç³»ç»Ÿ

## ğŸ“š å‚è€ƒèµ„æº

- [Calimero Network æ–‡æ¡£](https://docs.calimero.network)
- [Calimero SDK å‚è€ƒ](https://sdk.calimero.network)
- [NEAR Protocol å¼€å‘æŒ‡å—](https://docs.near.org)
- [Rust å¼‚æ­¥ç¼–ç¨‹](https://rust-lang.github.io/async-book/)

---

**ç‰ˆæœ¬**: 1.0.0  
**æœ€åæ›´æ–°**: 2024å¹´8æœˆ28æ—¥  
**ç»´æŠ¤è€…**: Calimero å¼€å‘å›¢é˜Ÿ
